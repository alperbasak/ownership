name: CODEOWNERS Auto Approve

on:
  pull_request:
    types: [ opened, synchronize, reopened ]
  pull_request_review:
    types: [ submitted, dismissed ]

jobs:
  auto-approve:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Auto approve if author owns all files
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.BOT_PAT }}
          script: |
            const fs = require('fs');
            
            // ============================================
            // 1. GET BASIC INFO
            // ============================================
            const { data: bot } = await github.rest.users.getAuthenticated();
            const author = context.payload.pull_request.user.login;
            const prNumber = context.payload.pull_request.number;
            
            console.log(`Bot: @${bot.login}`);
            console.log(`Author: @${author}`);
            console.log(`PR: #${prNumber}`);
            console.log(`Event: ${context.eventName}`);
            
            // Skip if this was triggered by bot's own review
            if (context.eventName === 'pull_request_review') {
              const reviewer = context.payload.review.user.login;
              const action = context.payload.action;
              const reviewState = context.payload.review.state;
              console.log(`Triggered by ${action} from: @${reviewer}`);
              console.log(`Review state: ${reviewState}`);
            
              if (reviewer === bot.login) {
                console.log('‚è≠Ô∏è  Skipping - triggered by bot itself');
                return;
              }
              
              // Log explicitly when handling a dismissal
              if (action === 'dismissed') {
                console.log(`‚ö†Ô∏è  Dismissal detected from @${reviewer} - will re-evaluate all approvals`);
              }
            }
            
            // ============================================
            // 2. GET CHANGED FILES
            // ============================================
            // Fetch ALL changed files with pagination (GitHub API limit is 100 per page)
            const allFiles = [];
            let page = 1;
            let hasMore = true;
            
            console.log('Fetching changed files...');
            while (hasMore) {
              const { data: files } = await github.rest.pulls.listFiles({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                per_page: 100,
                page: page
              });
              
              allFiles.push(...files);
              console.log(`  Page ${page}: ${files.length} files`);
              
              // If we got less than 100 files, we've reached the end
              hasMore = files.length === 100;
              page++;
              
              // Safety check: GitHub's API has a limit of 3000 files per PR
              if (allFiles.length >= 3000) {
                console.log('‚ö†Ô∏è  Warning: PR has 3000+ files (GitHub API limit reached)');
                break;
              }
            }
            
            const changedFiles = allFiles.map(f => f.filename);
            console.log(`Total files changed: ${changedFiles.length}`);
            
            if (changedFiles.length === 0) {
              console.log('No files to check');
              return;
            }
            
            // Warn if PR is very large
            if (changedFiles.length > 300) {
              console.log(`‚ö†Ô∏è  Large PR detected: ${changedFiles.length} files changed`);
            }
            
            // ============================================
            // 3. LOAD CODEOWNERS
            // ============================================
            const codeownersPath = '.github/CODEOWNERS';
            if (!fs.existsSync(codeownersPath)) {
              console.log('CODEOWNERS file not found');
              return;
            }
            
            const rules = fs.readFileSync(codeownersPath, 'utf8')
              .split('\n')
              .filter(line => line.trim() && !line.startsWith('#'))
              .map(line => {
                const [pattern, ...owners] = line.trim().split(/\s+/);
                return { pattern, owners };
              })
              .filter(rule => rule.owners.length > 0);
            
            console.log(`CODEOWNERS rules: ${rules.length}`);
            
            // ============================================
            // 4. GET EXISTING APPROVALS
            // ============================================
            const { data: reviews } = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            
            // Get latest review state per reviewer (last review wins)
            const approvers = new Set();
            const reviewsByUser = {};
            let botApprovalId = null;
            
            console.log(`Total reviews: ${reviews.length}`);
            
            for (const review of reviews) {
              // Only keep the latest review per user
              if (!reviewsByUser[review.user.login] || review.id > reviewsByUser[review.user.login].id) {
                reviewsByUser[review.user.login] = review;
              }
            }
            
            console.log(`\n--- Review States ---`);
            for (const [user, review] of Object.entries(reviewsByUser)) {
              // Track bot's own approval
              if (user === bot.login) {
                if (review.state === 'APPROVED') {
                  botApprovalId = review.id;
                  console.log(`Bot has existing approval (id: ${botApprovalId})`);
                } else {
                  console.log(`Bot review state: ${review.state} (no active approval)`);
                }
                continue;
              }
            
              // Only count if state is APPROVED (not DISMISSED, CHANGES_REQUESTED, etc.)
              if (review.state === 'APPROVED') {
                approvers.add(user);
                console.log(`‚úÖ @${user}: APPROVED`);
              } else {
                console.log(`‚ùå @${user}: ${review.state}`);
              }
            }
            
            console.log(`\nActive approvers (excluding bot): ${Array.from(approvers).map(u => '@' + u).join(', ') || 'none'}`);
            
            // ============================================
            // 5. HELPER FUNCTIONS
            // ============================================
            
            // Check if username is in a GitHub team
            async function isInTeam(username, teamSlug) {
              try {
                const [org, team] = teamSlug.replace('@', '').split('/');
                if (!org || !team) return false;
            
                await github.rest.teams.getMembershipForUserInOrg({
                  org, team_slug: team, username
                });
                return true;
              } catch {
                return false;
              }
            }
            
            // Check if username is in the owners list (direct or via team)
            async function isOwner(username, owners) {
              for (const owner of owners) {
                if (owner === `@${username}`) return true;
                if (owner.includes('/') && await isInTeam(username, owner)) return true;
              }
              return false;
            }
            
            // Check if file matches CODEOWNERS pattern
            function matches(file, pattern) {
              if (pattern === '*') return true;
            
              // Normalize: remove leading slash from pattern for comparison
              const normalizedPattern = pattern.startsWith('/') ? pattern.slice(1) : pattern;
            
              // Directory pattern: /backend/ or /backend matches backend/*
              if (normalizedPattern.endsWith('/')) {
                const dir = normalizedPattern.slice(0, -1);
                return file.startsWith(dir + '/') || file === dir;
              }
            
              // Check if file starts with the pattern (for directory matches)
              if (file.startsWith(normalizedPattern + '/')) {
                return true;
              }
            
              // Exact match or glob pattern
              const regex = new RegExp(
                '^' + normalizedPattern.replace(/\./g, '\\.').replace(/\*/g, '.*') + '$'
              );
              return regex.test(file);
            }
            
            // Find owners for a file (LAST matching rule wins - CODEOWNERS behavior)
            function findOwners(file) {
              let owners = null;
              let pattern = null;
            
              // Iterate through ALL rules, last match wins
              for (const rule of rules) {
                if (matches(file, rule.pattern)) {
                  owners = rule.owners;
                  pattern = rule.pattern;
                }
              }
            
              return { owners, pattern };
            }
            
            // Check if any owner from the list has approved (excluding bot and author)
            async function hasRequiredApproval(owners) {
              for (const owner of owners) {
                // Skip bot itself
                if (owner === `@${bot.login}`) continue;
            
                // Skip author (they can't approve their own PR)
                if (owner === `@${author}`) continue;
            
                // Check direct user approval
                if (owner.startsWith('@')) {
                  const username = owner.slice(1);
                  if (approvers.has(username)) {
                    return true;
                  }
                }
            
                // Check team member approval
                if (owner.includes('/')) {
                  for (const approver of approvers) {
                    if (await isInTeam(approver, owner)) {
                      return true;
                    }
                  }
                }
              }
              return false;
            }
            
            // ============================================
            // 6. CHECK EACH FILE
            // ============================================
            console.log('\n--- Checking files ---');
            
            let shouldApprove = true;
            let botAuthorized = true;
            const filesNeedingApproval = [];
            
            for (const file of changedFiles) {
              const { owners, pattern } = findOwners(file);
            
              if (!owners) {
                console.log(`${file}: no owners found`);
                continue;
              }
            
              const botIsOwner = await isOwner(bot.login, owners);
              const authorIsOwner = await isOwner(author, owners);
            
              console.log(`${file}:`);
              console.log(`  pattern: ${pattern}`);
              console.log(`  owners: ${owners.join(', ')}`);
              console.log(`  bot is owner: ${botIsOwner}`);
              console.log(`  author is owner: ${authorIsOwner}`);
            
              // Bot must be in owners to approve
              if (!botIsOwner) {
                console.log(`  ‚ùå Bot not authorized for this file`);
                console.log(`  Fix: Add @${bot.login} to pattern: ${pattern}`);
                shouldApprove = false;
                botAuthorized = false;
                break;
              }
            
              // Check if file needs approval from others
              if (!authorIsOwner) {
                const hasApproval = await hasRequiredApproval(owners);
                console.log(`  Author doesn't own this file`);
                console.log(`  Has required approval: ${hasApproval}`);
            
                if (!hasApproval) {
                  filesNeedingApproval.push({ file, pattern, owners });
                  shouldApprove = false;
                }
              }
            }
            
            // ============================================
            // 7. APPROVE OR DISMISS
            // ============================================
            console.log('\n--- Decision ---');
            
            if (!shouldApprove) {
              // Only dismiss bot approval if bot is actually authorized
              // (if bot is not authorized, it shouldn't have approved in the first place)
              if (botAuthorized && botApprovalId) {
                console.log('üîÑ Dismissing bot\'s previous approval (conditions no longer met)...');
                
                // Build a concise dismissal message (GitHub has comment size limits)
                let dismissMessage = 'Approval requirements no longer met';
                
                if (filesNeedingApproval.length > 0) {
                  // Group files by required owners to make message concise
                  const ownerGroups = new Map();
                  
                  for (const { file, owners } of filesNeedingApproval) {
                    const nonBotOwners = owners.filter(o => o !== `@${bot.login}` && o !== `@${author}`);
                    const ownersKey = nonBotOwners.sort().join(', ');
                    
                    if (!ownerGroups.has(ownersKey)) {
                      ownerGroups.set(ownersKey, []);
                    }
                    ownerGroups.get(ownersKey).push(file);
                  }
                  
                  // Build message with file count limits to avoid huge messages
                  const parts = [];
                  for (const [owners, files] of ownerGroups) {
                    if (files.length <= 3) {
                      // Show all files if 3 or fewer
                      parts.push(`${files.join(', ')} need${files.length === 1 ? 's' : ''} approval from: ${owners}`);
                    } else {
                      // Summarize if many files
                      parts.push(`${files.length} files need approval from: ${owners} (e.g., ${files.slice(0, 2).join(', ')}, ...)`);
                    }
                  }
                  
                  // Limit message length (GitHub comment limit is ~65536 chars, be safe at 1000)
                  const fullMessage = `Waiting for required approvals:\n${parts.join('\n')}`;
                  if (fullMessage.length > 1000) {
                    dismissMessage = `Waiting for required approvals: ${filesNeedingApproval.length} file(s) need review. See workflow logs for details.`;
                  } else {
                    dismissMessage = fullMessage;
                  }
                }
                
                try {
                  await github.rest.pulls.dismissReview({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: prNumber,
                    review_id: botApprovalId,
                    message: dismissMessage
                  });
                  console.log('‚úÖ Bot approval dismissed');
                  console.log(`   Message: ${dismissMessage}`);
                } catch (error) {
                  console.log(`‚ö†Ô∏è  Could not dismiss approval: ${error.message}`);
                }
              } else {
                if (!botAuthorized) {
                  console.log('‚ö†Ô∏è  Bot not authorized to approve - no dismissal needed');
                }
                if (!botApprovalId) {
                  console.log('‚ÑπÔ∏è  No existing bot approval to dismiss');
                }
              }
            
              if (filesNeedingApproval.length > 0) {
                console.log('‚ùå Waiting for required approvals:');
                filesNeedingApproval.forEach(({ file, pattern, owners }) => {
                  const nonBotOwners = owners.filter(o => o !== `@${bot.login}` && o !== `@${author}`);
                  console.log(`  ${file} (${pattern}) needs: ${nonBotOwners.join(', ')}`);
                });
              } else if (!botAuthorized) {
                console.log('‚ùå Bot not authorized for all files');
              }
            
              return;
            }
            
            console.log('‚úÖ All conditions met, approving...');
            console.log(`   Reason: ${author} owns all changed files OR required approvals exist`);
            
            // Build approval message with context about PR size
            let approvalBody = '‚úÖ Auto-approved: All CODEOWNERS requirements are met';
            if (changedFiles.length > 100) {
              approvalBody += `\n\nüìä Large PR: ${changedFiles.length} files changed`;
            }
            if (changedFiles.length > 1000) {
              approvalBody += ' - Consider splitting into smaller PRs for easier review';
            }
            
            try {
              await github.rest.pulls.createReview({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                event: 'APPROVE',
                body: approvalBody
              });
              console.log('‚úÖ PR approved');
            } catch (error) {
              if (error.status === 422) {
                console.log('‚ÑπÔ∏è  Already approved or cannot approve (same user as author)');
              } else {
                throw error;
              }
            }
